---
title: FormController.ts
description: Reference for the FormController class
navigation:
  icon: material-symbols:code
seo:
  <!-- title: Quick Start -->
  <!-- description: Get started with Goodie Forms core, a headless TypeScript form state and data management library. Learn how to install, register fields, add validation, and handle form submission with full control. -->
---

## Overview

```ts
export class FormController<TOutput extends object>
```

::doc-tree
:::doc-tree-item{title="TOutput"}
represents the final validated shape of your form data. It defines the full object structure that the form is expected to produce after successful validation and submission.
:::
::

`FormController<TOutput>` is the central state manager of your form â€” a single, type-safe source of truth that orchestrates data, fields, validation, and submission lifecycle.

It holds and mutates form data immutably (powered by [immer](https://immerjs.github.io/immer/)), tracks field registration dynamically, manages dirty/touched state, and coordinates schema-based validation via [StandardSchemaV1](https://standardschema.dev/).
Through its event system, it emits fine-grained updates for value changes, validation, submission status, and field lifecycle events â€” making it framework-agnostic and highly reactive.

With `FormController`, you can:

- Maintain _deeply nested_, _strongly-typed_ form data
- Register/unregister fields dynamically
- Track `dirty`, `valid`, `validating`, and `submitting` states
- Run _partial_ or _full_ schema validation on demand
- Generate **robust submit handlers** with **built-in error focusing**
- React to granular **form events** _without_ coupling to UI

In short, `FormController` is the core engine that keeps your form **predictable**, **extensible**, and **fully controlled**.

---

## Fields

### ðŸ“˜ `this.data`

::doc-ref-section
```ts
data: DeepReadonly<DeepPartial<TOutput>>;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

Returns an immutable version of current **form data**.
::

### ðŸ“˜ `this.initialData`

::doc-ref-section
```ts
initialData: DeepReadonly<DeepPartial<TOutput>>;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

Returns an immutable version of **initial form data**.
::

### ðŸ“˜ `this.issues`

::doc-ref-section
```ts
issues: readonly StandardSchemaV1.Issue[];
```

Returns an immutable list of current issues.
::

### ðŸ“˜ `this.path`

::doc-ref-section
```ts
path: FieldPathBuilder<TOutput>;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

A very handy helper to build segmented paths off of `TOutput`

#### Examples

```ts
formController.path.of("username"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.username);
```

```ts
formController.path.of("address.city"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.address.city);
```

```ts
formController.path.of("friends[42].name"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.friends[42].name);
```
::

### ðŸ“˜ `this.isDirty`

::doc-ref-section
```ts
isDirty: boolean;
```

Returns whether there exists a registered field that is dirty.
::

### ðŸ“˜ `this.isValid`

::doc-ref-section
```ts
isValid: boolean;
```

Returns whether none of the registered fields have an issue.
::

### ðŸ“˜ `this.isValidating`

::doc-ref-section
```ts
isValidating: boolean;
```

Returns whether controller is currently validating or not.
::

### ðŸ“˜ `this.isSubmitting`

::doc-ref-section
```ts
isSubmitting: boolean;
```

Returns whether controller is currently submitting or not.
::

### ðŸ“˜ `this.triedSubmitting`

::doc-ref-section
```ts
triedSubmitting: boolean;
```

Returns whether controller has tried to submit before.

This value is set to `true` at the very first submission trial.
::

---

## Events

### ðŸ“˜ `this.events`

::doc-ref-section
```ts
declare const events: NanoEvents<{
  // Emitted when `this.isSubmitting` changes
  submissionStatusChange(isSubmitting: boolean): void;
  // Emitted when `this.isValidating` changes
  validationStatusChange(isValidating: boolean): void;

  // Emitted when a field is registered
  fieldRegistered(fieldPath: FieldPath.Segments): void;
  // Emitted when a field is unregistered
  fieldUnregistered(fieldPath: FieldPath.Segments): void;
  // Emitted when a field's `isTouched` changes
  fieldTouchUpdated(path: FieldPath.Segments): void;
  // Emitted when a field's `isDirty` changes
  fieldDirtyUpdated(path: FieldPath.Segments): void;
  // Emitted when a field's `issues` changes
  fieldIssuesUpdated(fieldPath: FieldPath.Segments): void;

  // Emitted when a HTMLELement is bound to a field
  elementBound(fieldPath: FieldPath.Segments, el: HTMLElement): void;
  // Emitted when a HTMLELement is unbound from a field
  elementUnbound(fieldPath: FieldPath.Segments): void;

  // Emitted when validation is triggered on a field
  validationTriggered(fieldPath: FieldPath.Segments): void;

  // Emitted when a field's `value` is updated
  valueChanged(
    fieldPath: FieldPath.Segments,
    newValue: {} | undefined,
    oldValue: {} | undefined,
  ): void;
}>;
```

Reactive event bus of the `FormController`.

All state transitions inside the controller are emitted through this object.
It allows UI adapters, bindings, devtools or external observers to react to form changes without directly coupling to internal state.

#### Examples
`this.events` is powered by [NanoEvents](https://github.com/ai/nanoevents), a minimal, dependency-free event emitter.

It provides a simple and predictable API:
```ts
const unsubscribe = formController.events.on(
  "valueChanged", // <-- IntelliSense works here!
  (path, next, prev) => {
    console.log("Changed:", path, prev, "->", next);
  },
);

// ... later on

unsubscribe();
```
::

## Methods

### ðŸ“™ `Constructor`

::doc-ref-section
```ts
declare namespace FormController {
  export type Configs<TOutput extends object> = {
    initialData?: DeepPartial<TOutput>;
    validationSchema?: StandardSchemaV1<unknown, TOutput>;
    equalityComparators?: Map<any, (a: any, b: any) => boolean>;
  };
}
```
```ts
constructor(config: FormController.Configs<TOutput>)
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

Constructs a new form controller that holds `data`, `initialData` and registered fields.
The form controller is the brain of the whole ecosystem.

#### Returns
```ts
FormController<TOutput>;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

#### Constructor Args

:::field-group
::::field{name="config.validationSchema?:" type="StandardSchemaV1"}
If present, the controller will use this schema to perform validations.
::::
::::field{name="config.initialData?:" type="DeepPartial<TOutput>"}
A deeply partial version of `TOutput`. If present, form will use these values as initial.
::::
::::field{name="config.equalityComparators?:" type="Map<any, (a: any, b: any) => boolean>"}
A lookup for custom equality comparators. It is used to determine if a data value is dirty, by comparing to the corresponding initialData value.
::::
:::

#### Examples

```ts
const formController = new FormController<User>({});
// ^ TOutput can be explicitly declared
```

```ts
const formController = new FormController({
  validationSchema: UserSchema, // <-- TOutput can also be infered from the schema
});
```

```ts
const formController = new FormController({
  validationSchema: UserSchema,
  initialData: { username: "" },
});
```

```ts
class Address { ... }

const formController = new FormController({
  // You can impl a custom comparison strategy for classes
  equalityComparators: new Map([
    [Address, (a: Address, b: Address) => a.equals(b)]
  ])
});
```
::

### ðŸ“™ `registerField()`

::doc-ref-section
```ts
declare function registerField<TPath extends FieldPath.Segments>(
  path: TPath,
  config?: {
    defaultValue?: Suppliable<FieldPath.Resolve<TOutput, TPath>>;
    overrideInitialValue?: boolean;
  },
);
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
::::doc-tree-item{title="TPath"}
segmented path of the field respective to `TOutput`
::::
:::

Creates a new `FormField` sitting at given `TPath`, registers it to this controller and returns.

#### Returns

```ts
FormField<TOutput, FieldPath.Resolve<TOutput, TPath>>;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
::::doc-tree-item{title="TPath*"}
from `registerField()`s generics (See [registerField()](#registerfield))
::::
::::doc-tree-item{title="FieldPath.Resolve<TOutput, TPath>"}
value type of `TOutput` at given `TPath`
::::
:::

Field created and registered to the controller:

#### Arguments

:::field-group
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Represents where this field is supposed to sit at `TOutput`.
Used while modifying, reading and validating the value of this field.
::::
::::field{name="config.defaultValue?:" type="Suppliable<FieldPath.Resolve<TOutput, TPath>>"}
If present, it will be used to set value of `this.data` at `TPath` when current value is `null | undefined`.
::::
::::field{name="config.overrideInitialValue?:" type="boolean"}
If `true`, value of `this.initialData` at `TPath` will also change with `defaultValue` when current value is `null | undefined`.
::::
:::

#### Examples

```ts
const path = formController.path.of("username");
const field = formController.registerField(path);
// formController will now have "username" field registered
```

```ts
const path = formController.path.of("email");
const field = formController.registerField(path, {
  defaultValue: "john@doe.com",
});
console.log(field.value); // <-- "john@doe.com"
console.log(field.isDirty); // <-- true
```

```ts
const path = formController.path.of("email");
const field = formController.registerField(path, {
  defaultValue: "john@doe.com",
  overrideInitialValue: true,
});
console.log(field.value); // <-- "john@doe.com"
console.log(field.isDirty); // <-- false
```
::

### ðŸ“™ `unregisterField()`

::doc-ref-section
```ts
declare function unregisterField(path: FieldPath.Segments);
```

Removes the field at the given `path` from the controller.

If a field exists at the provided `path`, it is removed from the internal registry and a `fieldUnregistered` [event](#thisevents) is emitted.

#### Returns
```ts
boolean;
```
- `true` â†’ A field was found and successfully unregistered
- `false` â†’ No field was registered at the given path

#### Arguments
:::field-group
::::field{name="path!" type="FieldPath.Segments"}
Segmented path of the field to be removed.

Must match the exact path used during `registerField()`.
::::
:::

#### Examples

```ts
const path = formController.path.of("username");
formController.unregisterField(path);
```

```ts
const path = formController.path.of("username");
const field = formController.registerField(path);
formController.unregisterField(field.path); // <-- true
```
::

### ðŸ“™ `getField()`

::doc-ref-section
```ts
declare function getField<TPath extends FieldPath.Segments>(path: TPath);
```
:::doc-tree
::::doc-tree-item{title="TPath"}
segmented path of the field
::::
:::

Returns the registered `FormField` at the given `TPath`, if it exists.

If no field has been registered at the provided `path`, `undefined` is returned.

:::warning
Behavior Notes

- `getField()` **does not** create or register a field.
- It only retrieves **an already registered** field.
- Safe to call _repeatedly_.
- Fully type-safe â€” the returned field's value type is inferred from `TPath`.
:::

:::warning
If you need to ensure a field exists, call `registerField()` first.
:::

#### Returns

```ts
FormField<TOutput, FieldPath.Resolve<TOutput, TPath>> | undefined;
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
::::doc-tree-item{title="TPath*"}
from `getField()`'s generics (See [getField()](#getfield))
::::
::::doc-tree-item{title="FieldPath.Resolve<TOutput, TPath>"}
value type of `TOutput` at given `TPath`
::::
:::

#### Arguments
:::field-group
::::field{name="path!" type="FieldPath.Segments"}
Segmented path pointing to a field inside `TOutput`.
Must match the exact path used during `registerField()`.
::::
:::

#### Examples
```ts
const path = formController.path.of("email");

const field = formController.getField(path);

console.log(field); // undefined (if not registered yet)
```
```ts
interface Model {
  email: string;
}

const formController = new FormController<Model>({});

const path = formController.path.of("email");

formController.registerField(path);

const field = formController.getField(path);
//    ^? FormField<Model, string> | undefined

console.log(field?.value);
//                 ^? string | undefined
```
::

### ðŸ“™ `reset()`

::doc-ref-section
```ts
declare function reset(newInitialData?: DeepPartial<TOutput>);
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
:::

Resets the form back to its **initial state**.

All registered fields are reset, validation issues are cleared, submission flags are restored, and `data` is reverted to `initialData`.

If `newInitialData` is provided, it becomes the new source of truth for both `initialData` and `data`.

#### Arguments
:::field-group
::::field{name="newInitialData?:" type="DeepPartial<TOutput>"}
If provided, replaces the current `initialData` and reinitializes `data` from it.
::::
:::

#### Examples
```ts
// Reset to original initialData
formController.reset();
```
```ts
// Replace initialData entirely
formController.reset({
  username: "john",
  email: "john@doe.com",
});
formController.data; // { username:"john", email: "john@doe.com" }
formController.initialData; // { username:"john", email: "john@doe.com" }
```
```ts
// After reset
console.log(formController.isTouched); // false
console.log(formController.isDirty); // false
console.log(formController.issues); // []
console.log(formController.triedSubmitting); // false
```
::

### ðŸ“™ `validateForm()`

::doc-ref-section
```ts
declare function validateForm();
```

Runs full-form validation using the configured `validationSchema`.

All registered fields are validated against the current `data`.
Validation issues are reconciled, updated, and corresponding events are emitted.

:::note
Behavior

- Skips execution if:
  - Validation is already in progress (`isValidating === true`)
  - No `validationSchema` is configured
- Sets `isValidating` â†’ `true` during execution
- Validates the entire `data` object
- Reconciles validation issues per registered field
- Emits:
  - `validationStatusChange`
  - `validationTriggered` (for each registered field)
  - `fieldIssuesUpdated` (when issues change)
- Sets `isValidating` â†’ `false` after completion

Validation issues not tied to registered fields are still stored in `this.issues`.
:::

#### Returns
```ts
Promise<void>;
```
Resolves when validation completes.

#### Examples
```ts
await formController.validateForm();

if (formController.isValid) {
  console.log("Form is valid!");
} else {
  console.log("Issues:", formController.issues);
}
```
```ts
// Trigger validation without submitting
button.innerHTML = "Validate";
button.onclick = async () => {
  await formController.validateForm();
};
```
::

### ðŸ“™ `validateField()`

::doc-ref-section
```ts
declare function validateField<TPath extends FieldPath.Segments>(path: TPath);
```

:::doc-tree
::::doc-tree-item{title="TPath"}
segmented path of the field to validate
::::
:::

Runs validation for a specific field path.

The entire `data` object is validated using the configured `validationSchema`,
but only issues related to the given `TPath` (and its descendants) are reconciled and updated.

:::note
Behavior

- Skips execution if:
  - Validation is already in progress (`isValidating === true`)
  - No `validationSchema` is configured
- Sets `isValidating` â†’ `true` during execution
- Ensures the field is registered (auto-registers if missing)
- Validates the entire `data` object
- Reconciles issues affecting:
  - The exact `path`
  - Any descendant paths
- Emits:
  - `validationStatusChange`
  - `validationTriggered` (for the given path)
  - `fieldIssuesUpdated` (if issues changed)
- Sets `isValidating` â†’ `false` after completion
:::

#### Returns
```ts
Promise<void>;
```
Resolves when validation completes.

#### Arguments
:::field-group
::::field{name="path" type="TPath extends FieldPath.Segments"}
Segmented path of the field to validate.
::::
:::

#### Examples
```ts
const path = formController.path.of("email");

const field = formController.getField(path);

await formController.validateField(path);

if (field.isValid) {
  console.log("Field is valid!");
} else {
  console.log("Issues:", field.issues);
}
```
```ts
// Trigger validation without submitting
button.innerHTML = "Validate";
button.onclick = async () => {
  const path = formController.path.of("email");
  await formController.validateField(path);
};
```
::

### ðŸ“™ `createSubmitHandler()`

::doc-ref-section
```ts
declare namespace FormController {
  export interface PreventableEvent {
    preventDefault(): void;
  }

  export type SubmitSuccessHandler<
    TOutput extends object,
    TEvent extends PreventableEvent | null | undefined,
  > = (data: DeepReadonly<TOutput>, event: TEvent) => void | Promise<void>;

  export type SubmitErrorHandler<
    TEvent extends PreventableEvent | null | undefined,
  > = (issues: StandardSchemaV1.Issue[], event: TEvent) => void | Promise<void>;
}
```
```ts
declare function createSubmitHandler<
  TEvent extends FormController.PreventableEvent | null | undefined,
>(
  onSuccess?: FormController.SubmitSuccessHandler<TOutput, TEvent>,
  onError?: FormController.SubmitErrorHandler<TEvent>,
);
```
:::doc-tree
::::doc-tree-item{title="TOutput*"}
from `FormController`'s generics (See [#Overview](#overview))
::::
::::doc-tree-item{title="TEvent"}
Event type passed from the consumer (e.g. `SubmitEvent`)
::::
:::

Creates a fully managed submit handler for the form.

The returned function handles:

- `event.preventDefault()` (if event exists)
- Full-form validation
- Submission state tracking
- Automatic focusing of the first invalid field
- Calling `onSuccess` or `onError` based on validation

#### Returns
```ts
(event: TEvent) => Promise<void>;
```
:::doc-tree
::::doc-tree-item{title="TEvent*"}
from `createSubmitHandler()`'s generics (See [createSubmitHandler()](#createsubmithandler))
::::
:::

#### Arguments
:::field-group
::::field{name="onSuccess?:" type="FormController.SubmitSuccessHandler<TOutput, TEvent>"}
Called when validation passes and there are no issues. Receives fully-typed form data `TOutput`, and the original `event`.
::::
::::field{name="onError?:" type="FormController.SubmitErrorHandler<TEvent>"}
Called when validation fails. Receives all validation `issues`, and the original `event`.
::::
:::

#### Examples
```ts
interface Model {
  username: string;
  password: string;
}

const formController = new FormController<Model>();
const formEl = document.getElementById("my-form") as HTMLFormElement;

formEl.onsubmit = formController.createSubmitHandler(
  async (data, event) => {
    //         ^? SubmitEvent, inferred automatically
    await api.loginUser(data);
    //                  ^? Model
  },
  async (issues) => {
    console.error("Validation failed:", issues);
    //                                  ^? StandardSchemaV1.Issue[]
  },
);
```
```ts
// With explicit event typing
const handleSubmit = formController.createSubmitHandler<SubmitEvent>(
  async (data, event) => {
    console.log("Submitting:", data);
  },
);
```
::

---

## Recipes

### ðŸ“š Basic Form with Schema Validation

::doc-ref-section
**Goal**: Validate a simple login form and submit safely.

```ts
type LoginForm = {
  email: string;
  password: string;
};

const formController = new FormController<LoginForm>({
  initialData: {
    email: "",
    password: "",
  },
  validationSchema: loginSchema, // StandardSchemaV1
});

const emailField = formController.registerField(form.path.of("email"));

const passwordField = formController.registerField(form.path.of("password"));

const handleSubmit = formController.createSubmitHandler(async (data) => {
  await api.login(data);
});

formEl.onsubmit = handleSubmit;
```
::

### ðŸ“š Default Values for Dynamically Mounted Fields

::doc-ref-section
**Goal**: Provide fallback values when a field appears conditionally.

```ts
const field = formController.registerField(
  formController.path.of("profile.bio"),
  { defaultValue: "Hello there ðŸ‘‹" },
);
```

If `data.profile.bio` is `null | undefined`, it gets initialized.

To also modify `initialData`:

```ts
formController.registerField(formController.path.of("profile.bio"), {
  defaultValue: "Hello there ðŸ‘‹",
  overrideInitialValue: true,
});
```
::

### ðŸ“š On-Blur Field Validation

::doc-ref-section
**Goal**: Validate only the field the user just left.

```ts
const path = formController.path.of("email");

input.onblur = async () => {
  await formController.validateField(path);
};
```
::

### ðŸ“š Reset With New Server Data

::doc-ref-section
**Goal**: Rehydrate form after fetching user data.

```ts
const user = await api.getUser();

formController.reset(user);
```

This:

- Replaces `initialData`
- Recreates data
- Clears issues
- Resets dirty/touched state
- Keeps fields registered

Perfect for edit forms.
::

### ðŸ“š Conditional Fields

::doc-ref-section
**Goal**: Dynamically add/remove fields.

```ts
const addressPath = form.path.of("address", "street");

if (showAddress) {
  form.registerField(addressPath);
} else {
  form.unregisterField(addressPath);
}
```

Data remains intact â€” only the field abstraction changes.
::

### ðŸ“š Disable Submit Button Reactively

::doc-ref-section
```ts
form.events.on("submissionStatusChange", (isSubmitting) => {
  submitButton.disabled = isSubmitting;
});
```
Or reflect validation:
```ts
form.events.on("validationStatusChange", (isValidating) => {
  spinner.visible = isValidating;
});
```
::
