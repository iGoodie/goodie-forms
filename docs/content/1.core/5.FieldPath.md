---
title: FieldPath.ts
description: Reference for the FieldPath namespace
navigation:
  icon: material-symbols:code
seo:
  <!-- title: Quick Start -->
  <!-- description: Get started with Goodie Forms core, a headless TypeScript form state and data management library. Learn how to install, register fields, add validation, and handle form submission with full control. -->
---

## Overview

```ts
export namespace FieldPath
```

`FieldPath` is the core abstraction behind form field management in the library.
It provides a **type-safe**, **runtime-aware** path system for **reading, writing, modifying, and deleting** deeply nested values inside complex objects ‚Äî including arrays.

At _runtime_, it handles:

- Converting between `["user", "address", 0, "city"]` and `"user.address[0].city"`
- Safely walking object trees (with auto-creation of missing branches)
- **Getting, setting, modifying, and deleting** deeply nested values
- Comparing and matching hierarchical paths

At the _type level_, it provides:

- Fully inferred string paths ("user.address[0].city")
- Compile-time validation of valid object paths
- Deep type resolution (`FieldPath.Resolve<TObject, TPath>`)
- Smart array index handling with **IntelliSense** support

In short, `FieldPath` ensures that form fields remain **structurally safe**, **deeply typed**, and **predictable**, whether you interact with them using string paths or segment arrays.
It acts as the **backbone** that keeps form state manipulation both **ergonomic** and **strongly** typed.

## Type Aliases

### üìó `Segments`

::doc-ref-section
```ts
export type Segments = readonly PropertyKey[];
```

Segments is the **canonical**, **low-level** representation of an object path.
Each entry corresponds to one navigation step inside an object or array.

It supports:

- `string` ‚Üí object keys
- `number` ‚Üí array indicecs
- `symbol` ‚Üí symbol keys

This format is what all runtime operations (`getValue()`, `setValue()`, `walkPath()`, etc.) operate on internally.

#### Examples

```ts
const path: FieldPath.Segments = ["user", "addresses", 0, "city"];
// ^ Represents obj.user.addresses[0].city
```

```ts
const path: FieldPath.Segments = ["grid". 10, 20, "coord", "x"]
// ^ Represents obj.grid[10][20].coord.x

```

```ts
const META = Symbol("meta");
const path: FieldPath.Segments = ["user", META, "createdAt"];
// ^ Represents: obj.user[META].createdAt
```
::

### üìó `StringPath`

::doc-ref-section
```ts
export type StringPath = string;
```

`StringPath` is the string representation of a field path.
It encodes deep object access using **dot notation** and **bracket indices**.

This is the **ergonomic**, **user-facing format** designed for APIs and declarative bindings ‚Äî internally,
it is parsed and normalized into `Segments` before any operation is performed.

Format Rules

- `.` separates object properties
- `[number]` represents array indices
- Nested structures combine both

#### Examples

```ts
const path: FieldPath.StringPath = "user.addresses[0].city";
// ^ Equivalent to: ["user", "addresses", 0, "city"]
```
```ts
const path: FieldPath.StringPath = "grid[10][20].coord.x";
// ^ Equivalent to: ["grid", 10, 20, "coord", "x"]
```

:::tip
`StringPath` values can be converted to `Segments` using `FieldPath.fromStringPath()`,
and `Segments` can be serialized back using `FieldPath.toStringPath()`.
:::

:::tip
An union of valid string-paths on a given `TObj extends object` can be extracted via `FieldPath.StringPaths<TObj>`,
enabling fully type-safe deep field references.
:::
::

## Type Helpers

### üìó `Resolve<>`

::doc-ref-section
```ts
export type Resolve<
  TObject,
  TPath extends FieldPath.Segments,
>;
```

`Resolve<>` computes the **exact value type** located at a given path.

Given an object type and a `FieldPath.Segments` path, it recursively walks the type and produces the type that exists at the end of that path ‚Äî including proper array index resolution and nullability handling.

It is the foundation that makes `getValue()`, `setValue()`, and `modifyValue()` fully type-safe.

`Resolve<>` is what bridges a structural path (`FieldPath.Segments`) with precise static type inference.

#### Examples
```ts
interface Model {
  user: {
    addresses: { city: string }[];
  };
}

type User = FieldPath.Resolve<Model, ["user"]>;
//   ^? { addresses: { city:string }[] }

type Addresses = FieldPath.Resolve<Model, ["user", "addresses"]>;
//   ^? { city:string }[]

type Address = FieldPath.Resolve<Model, ["user", "addresses", 0]>;
//   ^? { city:string }
type Address = FieldPath.Resolve<Model, ["user", "addresses", 99]>;
//   ^? { city:string }
type Address = FieldPath.Resolve<Model, ["user", "addresses", number]>;
//   ^? { city:string }

type City = FieldPath.Resolve<Model, ["user", "addresses", 0, "city"]>;
//   ^? string

type Nonexistent = FieldPath.Resolve<
  Model,
  ["invalid", "or", "missing", "field"]
>;
//   ^? never
```
```ts
const META = Symbol("meta");
type META = typeof META;

interface Model {
  [META]: { createdAt: Date };
}

type Meta = FieldPath.Resolve<Model, [META]>;
//   ^? { createdAt: Date }
```

:::note
If a path **does not exist** on the object, the resulting type becomes `never`, preventing invalid deep access at compile time.
:::
::

### üìó `StringPaths<>`

::doc-ref-section
```ts
export type StringPaths<TObject extends object>;
```

`StringPaths<>` generates the **complete union of all valid string paths** for a given object type `TObject`.

It **statically analyzes** the structure of `TObject` and produces _dot/bracket-notation_ paths that accurately reflect:

- Nested objects
- Arrays (with index support)
- Deeply composed structures

This enables strict **IntelliSense auto-complete** and **compile-time validation** for string-based field access.

#### Examples
:::tabs{.w-full}
::::tabs-item{icon="i-lucide-code" label="Code"}
```ts
type Model = {
  user: {
    name: string;
    addresses: { city: string }[];
  };
};

type ModelPath = FieldPath.StringPaths<Model>;
// ^ This will yield an union identical to this:
"user" |
  "user.name" |
  "user.addresses" |
  "user.addresses[0]" |
  `user.addresses[${number}]` |
  "user.addresses[0].city" |
  `user.addresses[${number}].city`;

const paths: ModelPath[] = [
  "user",
  "user.name",
  "user.addresses[42]",
  "user.addresses[0].city",
  "user.addresses[99].city",
  // ^ ‚úÖ Compiler is happy with these

  "user.invalid",
  // ^ ‚ùå Type error
];
```
::::

::::tabs-item{icon="i-lucide-eye" label="IntelliSense Preview"}
:::::note
Due to limitations in how IntelliSense represents array indices, only `[0]` is suggested.
However, accessing an array at any index is considered a valid string path.
:::::

![IntelliSense Preview of StringPaths<>](/doc/string-paths.intellisense.png)
::::
:::
::

### üìó `ParseStringPath<>`

::doc-ref-section
```ts
export type ParseStringPath<TStrPath extends string>;
```

`ParseStringPath<>` converts a **string path literal** into its exact `FieldPath.Segments` tuple type at compile time.

It interprets **dot notation** and **bracket indices**, producing a strongly typed path representation that can be consumed by `Resolve<>` and other `FieldPath.Segments`-based utilities.

This type is what bridges **ergonomic string literals** with the internal `FieldPath.Segments` system
‚Äî enabling full _compile-time validation_ and _deep type inference_ when working with **string-based field paths**.

#### Examples
```ts
type Path = FieldPath.ParseStringPath<"user.addresses[0].city">;
//   ^? ["user", "addresses", 0, "city"]
```
```ts
type IndexPath = FieldPath.ParseStringPath<"grid[10][20].x">;
//   ^? ["grid", 10, 20, "x"]
```
::

## Runtime Helpers

### üìô `walkPath()`

::doc-ref-section
```ts
export function walkPath<
  TObject extends object,
  const TPath extends FieldPath.Segments,
>(object: TObject, path: TPath, opts?: { returnOnEmptyBranch?: boolean });
```
:::doc-tree
::::doc-tree-item{title="TObject"}
The root object type that will be traversed and potentially mutated during path walking.
::::
::::doc-tree-item{title="TPath"}
A segmented path describing where traversal should occur within `TObject`.
Its structure dictates how branches are navigated _(and created, if necessary)_.
::::
:::

Traverses `object` up to the parent container of the final segment in `TPath`,
then returns **the container** and **the last key**.

It is the internal primitive powering `setValue()`, `modifyValue()`, and `deleteValue()`.

By default, missing intermediate branches are created automatically (object or array depending on the upcoming segment).

#### Returns
```ts
{
  target: any;
  key: PropertyKey | null;
}
```
:::doc-tree
::::doc-tree-item{title="target"}
The object that directly contains the final property.
::::
::::doc-tree-item{title="key"}
The last segment of `TPath`.
It will be `null` only when `returnOnEmptyBranch` is enabled and traversal stops early.
::::
:::

#### Arguments

:::field-group
::::field{name="object!" type="TObject extends object"}
Root object to traverse.
::::
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Segmented path to walk.
::::
::::field{name="config.returnOnEmptyBranch?:" type="boolean"}
If `true`, traversal stops and returns `{ target: null, key: null }` instead of creating missing branches.
::::
:::

#### Examples
```ts
const obj = {};

const path = ["user", "addresses", 0, "city"];
const { target, key } = FieldPath.walkPath(obj, path);
//              ^? "city"

target[key] = "Berlin";

console.log(obj);
// {
//   user: {
//     addresses: [
//       { city: "Berlin" }
//     ]
//   }
// }
```
```ts
const obj = {};

const path = ["user", "name"];
const result = FieldPath.walkPath(obj, path, {
  returnOnEmptyBranch: true,
});

console.log(result);
// { target: null, key: null }
```
::

### üìô `getValue()`

::doc-ref-section
```ts
export function getValue<
  TObject extends object,
  const TPath extends FieldPath.Segments,
>(object: TObject, path: TPath);
```
:::doc-tree
::::doc-tree-item{title="TObject"}
The root object type being traversed.
All type inference and deep resolution are computed relative to this structure.
::::
::::doc-tree-item{title="TPath"}
A segmented path pointing to a nested property inside `TObject`.
Its structure determines both the runtime traversal and the inferred return type via `FieldPath.Resolve<TObject, TPath>`.
::::
:::

Reads the value located at `TPath` inside `TObject`.

The return type is fully inferred using `FieldPath.Resolve<>`.

:::tip
**Traversal is safe** ‚Äî if any intermediate branch is `null` or `undefined`, the function immediately returns `undefined` instead of throwing.
:::

#### Returns
```ts
FieldPath.Resolve<TObject, TPath> | undefined;
```
:::doc-tree
::::doc-tree-item{title="TObject*"}
from `getValue()`'s generics (See [getValue()](#getvalue))
::::
::::doc-tree-item{title="TPath*"}
from `getValue()`'s generics (See [getValue()](#getvalue))
::::
::::doc-tree-item{title="FieldPath.Resolve<TOutput, TPath>"}
value type of `TOutput` at given `TPath`
::::
:::

#### Arguments

:::field-group
::::field{name="object!" type="TObject extends object"}
Root object to read from.
::::
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Segmented path pointing to the desired value.
::::
:::

#### Examples
```ts
const data = {
  user: {
    addresses: [{ city: "Berlin" }],
  },
};

const path = ["user", "addresses", 0, "city"];
const city = FieldPath.getValue(data, path);

// city inferred as: string | undefined
// value: "Berlin"
```
```ts
const data = {};

const path = ["user", "addresses", 0, "city"];
const city = FieldPath.getValue(data, path);

// city === undefined
// no runtime error
```
::

### üìô `setValue()`

::doc-ref-section
```ts
export function setValue<
  TObject extends object,
  const TPath extends FieldPath.Segments,
>(object: TObject, path: TPath, value: FieldPath.Resolve<TObject, TPath>);
```
:::doc-tree
::::doc-tree-item{title="TObject"}
The root object type being traversed.
Defines the full structural context in which the path will be resolved and mutated.
::::
::::doc-tree-item{title="TPath"}
A segmented path.
Determines both the target location inside `TObject` and the expected value type via `FieldPath.Resolve<TObject, TPath>`.
::::
:::

Writes `value` to `object` at the location described by `TPath`.

Missing intermediate branches are created automatically, ensuring the assignment always lands at the correct depth.

The `value` type is strictly inferred using `FieldPath.Resolve<>`, preventing invalid assignments at compile time.

#### Arguments

:::field-group
::::field{name="object!" type="TObject extends object"}
Root object to mutate.
::::
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Segmented path describing where the value should be written.
::::
::::field{name="value!" type="FieldPath.Resolve<TObject, TPath>"}
Value to assign at the given path.
Must match the exact resolved type of `TObject` at `TPath`.
::::
:::

#### Examples

```ts
const data = {};

const path = ["user", "addresses", 0, "city"];
FieldPath.setValue(data, path, "Berlin");

console.log(data);
// {
//   user: {
//     addresses: [
//       { city: "Berlin" }
//     ]
//   }
// }
```

```ts
type Model = {
  user: { age: number };
};

const model: Model = { user: { age: 18 } };

FieldPath.setValue(model, ["user", "age"], 25); // ‚úÖ
FieldPath.setValue(model, ["user", "age"], "25"); // ‚ùå Type error
```
::

### üìô `modifyValue()`

::doc-ref-section
```ts
export function modifyValue<
  TObject extends object,
  const TPath extends FieldPath.Segments,
>(
  object: TObject,
  path: TPath,
  modifier: (
    currentValue: FieldPath.Resolve<TObject, TPath> | undefined,
  ) => void,
);
```
:::doc-tree
::::doc-tree-item{title="TObject"}
The root object type whose structure defines where the modification occurs.
All type inference for the current value is derived from this shape.
::::
::::doc-tree-item{title="TPath"}
A segmented path describing the exact location inside `TObject` to modify.
It determines the type of `currentValue` through `FieldPath.Resolve<TObject, TPath>`.
::::
:::

Executes a mutation function against the value located at `TPath`.

Unlike `setValue()`, this does not replace the value directly.
Instead, it provides the current value to a `modifier` callback, allowing in-place updates (e.g. pushing into arrays or mutating objects).

Missing branches are created automatically before the modifier runs.

#### Arguments

:::field-group
::::field{name="object!" type="TObject extends object"}
Root object to mutate.
::::
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Segmented path pointing to the value to modify.
::::
::::field{name="modifier!" type="(currentValue: FieldPath.Resolve<TObject, TPath> | undefined) => void"}
Function that receives the current value and performs mutations on it.
::::
:::

#### Examples
```ts
const data = {
  user: {
    tags: [] as string[],
  },
};

const path = ["user", "tags"];
FieldPath.modifyValue(data, path, (tags) => {
  //                               ^? string[] | undefined
  tags?.push("admin");
});

console.log(data.user.tags);
// ["admin"]
```
```ts
const data = {};

const path = ["user", "count"];
FieldPath.modifyValue(data, path, (count) => {
  //                               ^? undefined
});
```
::

### üìô `deleteValue()`

::doc-ref-section
```ts
export function deleteValue<
  TObject extends object,
  TPath extends readonly PropertyKey[],
>(object: TObject, path: TPath);
```
:::doc-tree
::::doc-tree-item{title="TObject"}
The root object type being traversed.
Defines the structural boundary within which the deletion is evaluated.
::::
::::doc-tree-item{title="TPath"}
A segmented path pointing to the property inside `TObject` that should be removed.
Its structure determines which branch is walked at runtime.
::::
:::

Removes the property located at `TPath` from `object`.

Traversal is performed safely. If any intermediate branch does not exist, the operation exits without mutation.

Unlike `setValue()` or `modifyValue()`, this does not create missing branches.

#### Arguments

:::field-group
::::field{name="object!" type="TObject extends object"}
Root object to mutate.
::::
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Segmented path pointing to the property to delete.
::::
:::

#### Examples
```ts
const data = {
  user: {
    name: "John",
    age: 25,
  },
};

FieldPath.deleteValue(data, ["user", "age"]);

console.log(data);
// {
//   user: {
//     name: "John"
//   }
// }
```
```ts
const data = {};

FieldPath.deleteValue(data, ["user", "age"]);
// No error, no mutation
```
::
