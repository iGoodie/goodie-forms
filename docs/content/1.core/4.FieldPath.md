---
title: FieldPath.ts
description:
navigation:
  icon: material-symbols:code
seo:
  <!-- title: Quick Start -->
  <!-- description: Get started with Goodie Forms core, a headless TypeScript form state and data management library. Learn how to install, register fields, add validation, and handle form submission with full control. -->
---

## Overview

`FieldPath` is the core abstraction behind form field management in the library.
It provides a **type-safe**, **runtime-aware** path system for **reading, writing, modifying, and deleting** deeply nested values inside complex objects â€” including arrays.

At _runtime_, it handles:

- Converting between `["user", "address", 0, "city"]` and `"user.address[0].city"`
- Safely walking object trees (with auto-creation of missing branches)
- **Getting, setting, modifying, and deleting** deeply nested values
- Comparing and matching hierarchical paths

At the _type level_, it provides:

- Fully inferred string paths ("user.address[0].city")
- Compile-time validation of valid object paths
- Deep type resolution (`FieldPath.Resolve<TObject, TPath>`)
- Smart array index handling with **IntelliSense** support

In short, `FieldPath` ensures that form fields remain **structurally safe**, **deeply typed**, and **predictable**, whether you interact with them using string paths or segment arrays.
It acts as the **backbone** that keeps form state manipulation both **ergonomic** and **strongly** typed.

## Types

### ğŸ“— `Segments`

::doc-ref-section
```ts
export type Segments = readonly PropertyKey[];
```

Segments is the **canonical**, **low-level** representation of an object path.
Each entry corresponds to one navigation step inside an object or array.

It supports:

- `string` â†’ object keys
- `number` â†’ array indicecs
- `symbol` â†’ symbol keys

This format is what all runtime operations (`getValue`, `setValue`, `walkPath`, etc.) operate on internally.

#### Examples

```ts
const path: FieldPath.Segments = ["user", "addresses", 0, "city"];
// ^ Represents obj.user.addresses[0].city
```

```ts
const path: FieldPath.Segments = ["grid". 10, 20, "coord", "x"]
// ^ Represents obj.grid[10][20].coord.x

```

```ts
const META = Symbol("meta");
const path: FieldPath.Segments = ["user", META, "createdAt"];
// ^ Represents: obj.user[META].createdAt
```
::

### ğŸ“— `StringPath`

::doc-ref-section
```ts
export type StringPath = string;
```

`StringPath` is the string representation of a field path.
It encodes deep object access using **dot notation** and **bracket indices**.

This is the **ergonomic**, **user-facing format** designed for APIs and declarative bindings â€” internally,
it is parsed and normalized into `Segments` before any operation is performed.

Format Rules

- `.` separates object properties
- `[number]` represents array indices
- Nested structures combine both

#### Examples

```ts
const path: FieldPath.StringPath = "user.addresses[0].city";
// ^ Equivalent to: ["user", "addresses", 0, "city"]
```
```ts
const path: FieldPath.StringPath = "grid[10][20].coord.x";
// ^ Equivalent to: ["grid", 10, 20, "coord", "x"]
```

:::tip
`StringPath` values can be converted to `Segments` using `FieldPath.fromStringPath()`,
and `Segments` can be serialized back using `FieldPath.toStringPath()`.
:::

:::tip
An union of valid string-paths on a given `TObj extends object` can be extracted via `FieldPath.StringPaths<TObj>`,
enabling fully type-safe deep field references.
:::
::

## Type Helpers

### ğŸ“— `Resolve<>`

::doc-ref-section
```ts
export type Resolve<
  TObject,
  TPath extends FieldPath.Segments,
>;
```

`Resolve<>` computes the **exact value type** located at a given path.

Given an object type and a `FieldPath.Segments` path, it recursively walks the type and produces the type that exists at the end of that path â€” including proper array index resolution and nullability handling.

It is the foundation that makes `getValue`, `setValue`, and `modifyValue` fully type-safe.

`Resolve<>` is what bridges a structural path (`FieldPath.Segments`) with precise static type inference.

#### Examples
```ts
interface Model {
  user: {
    addresses: { city: string }[];
  };
}

type User = FieldPath.Resolve<Model, ["user"]>;
//   ^? { addresses: { city:string }[] }

type Addresses = FieldPath.Resolve<Model, ["user", "addresses"]>;
//   ^? { city:string }[]

type Address = FieldPath.Resolve<Model, ["user", "addresses", 0]>;
//   ^? { city:string }
type Address = FieldPath.Resolve<Model, ["user", "addresses", 99]>;
//   ^? { city:string }
type Address = FieldPath.Resolve<Model, ["user", "addresses", number]>;
//   ^? { city:string }

type City = FieldPath.Resolve<Model, ["user", "addresses", 0, "city"]>;
//   ^? string

type Nonexistent = FieldPath.Resolve<
  Model,
  ["invalid", "or", "missing", "field"]
>;
//   ^? never
```
```ts
const META = Symbol("meta");
type META = typeof META;

interface Model {
  [META]: { createdAt: Date };
}

type Meta = FieldPath.Resolve<Model, [META]>;
//   ^? { createdAt: Date }
```

:::note
If a path **does not exist** on the object, the resulting type becomes `never`, preventing invalid deep access at compile time.
:::
::

### ğŸ“— `StringPaths<>`

::doc-ref-section
```ts
export type StringPaths<TObject extends object>;
```

`StringPaths<>` generates the **complete union of all valid string paths** for a given object type `TObject`.

It **statically analyzes** the structure of `TObject` and produces _dot/bracket-notation_ paths that accurately reflect:

- Nested objects
- Arrays (with index support)
- Deeply composed structures

This enables strict **IntelliSense auto-complete** and **compile-time validation** for string-based field access.

#### Examples
:::tabs{.w-full}
::::tabs-item{icon="i-lucide-code" label="Code"}
```ts
type Model = {
  user: {
    name: string;
    addresses: { city: string }[];
  };
};

type ModelPath = FieldPath.StringPaths<Model>;
// ^ This will yield an union identical to this:
"user" |
  "user.name" |
  "user.addresses" |
  "user.addresses[0]" |
  `user.addresses[${number}]` |
  "user.addresses[0].city" |
  `user.addresses[${number}].city`;

const paths: ModelPath[] = [
  "user",
  "user.name",
  "user.addresses[42]",
  "user.addresses[0].city",
  "user.addresses[99].city",
  // ^ âœ… Compiler is happy with these

  "user.invalid",
  // ^ âŒ Type error
];
```
::::

::::tabs-item{icon="i-lucide-eye" label="IntelliSense Preview"}
:::::note
Due to limitations in how IntelliSense represents array indices, only `[0]` is suggested.
However, accessing an array at any index is considered a valid string path.
:::::

![IntelliSense Preview of StringPaths<>](/doc/string-paths.intellisense.png)
::::
:::
::

### ğŸ“— `ParseStringPath<>`

::doc-ref-section
```ts
export type ParseStringPath<TStrPath extends string>;
```

`ParseStringPath<>` converts a **string path literal** into its exact `FieldPath.Segments` tuple type at compile time.

It interprets **dot notation** and **bracket indices**, producing a strongly typed path representation that can be consumed by `Resolve<>` and other `FieldPath.Segments`-based utilities.

This type is what bridges **ergonomic string literals** with the internal `FieldPath.Segments` system 
â€” enabling full *compile-time validation* and *deep type inference* when working with **string-based field paths**.

#### Examples
```ts
type Path = FieldPath.ParseStringPath<"user.addresses[0].city">;
//   ^? ["user", "addresses", 0, "city"]

```
```ts
type IndexPath = FieldPath.ParseStringPath<"grid[10][20].x">;
//   ^? ["grid", 10, 20, "x"]
```
::

## Runtime Helpers

### ğŸ“™ `walkPath()`

### ğŸ“™ `getValue()`

### ğŸ“™ `setValue()`

### ğŸ“™ `modifyValue()`

### ğŸ“™ `deleteValue()`

::
