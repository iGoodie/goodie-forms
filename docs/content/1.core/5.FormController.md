---
title: FormController.ts
description: Reference for the FormController class
navigation:
  icon: material-symbols:code
seo:
  <!-- title: Quick Start -->
  <!-- description: Get started with Goodie Forms core, a headless TypeScript form state and data management library. Learn how to install, register fields, add validation, and handle form submission with full control. -->
---

## Overview

```ts
export class FormController<TOutput extends object>
```

::doc-tree
:::doc-tree-item{title="TOutput"}
represents the final validated shape of your form data. It defines the full object structure that the form is expected to produce after successful validation and submission.
:::
::

`FormController<TOutput>` is the central state manager of your form â€” a single, type-safe source of truth that orchestrates data, fields, validation, and submission lifecycle.

It holds and mutates form data immutably (powered by [immer](https://immerjs.github.io/immer/)), tracks field registration dynamically, manages dirty/touched state, and coordinates schema-based validation via [StandardSchemaV1](https://standardschema.dev/).
Through its event system, it emits fine-grained updates for value changes, validation, submission status, and field lifecycle events â€” making it framework-agnostic and highly reactive.

With `FormController`, you can:

- Maintain _deeply nested_, _strongly-typed_ form data
- Register/unregister fields dynamically
- Track `dirty`, `valid`, `validating`, and `submitting` states
- Run _partial_ or _full_ schema validation on demand
- Generate **robust submit handlers** with **built-in error focusing**
- React to granular **form events** _without_ coupling to UI

In short, `FormController` is the core engine that keeps your form **predictable**, **extensible**, and **fully controlled**.

---

## Fields

### ðŸ“˜ `this.data`

::doc-ref-section
```ts
data: DeepReadonly<DeepPartial<TOutput>>;
```

Returns an immutable version of current **form data**.
::

### ðŸ“˜ `this.initialData`

::doc-ref-section
```ts
initialData: DeepReadonly<DeepPartial<TOutput>>;
```

Returns an immutable version of **initial form data**.
::

### ðŸ“˜ `this.issues`

::doc-ref-section
```ts
issues: readonly StandardSchemaV1.Issue[];
```

Returns an immutable list of current issues.
::

### ðŸ“˜ `this.path`

::doc-ref-section
```ts
path: FieldPathBuilder<TOutput>;
```

A very handy helper to build segmented paths off of `TOutput`

#### Examples

```ts
formController.path.of("username"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.username);
```

```ts
formController.path.of("address.city"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.address.city);
```

```ts
formController.path.of("friends[42].name"); // <-- IntelliSense works!
// Or
formController.path.of((data) => data.friends[42].name);
```
::

### ðŸ“˜ `this.isDirty`

::doc-ref-section
```ts
isDirty: boolean;
```

Returns whether there exists a registered field that is dirty.
::

### ðŸ“˜ `this.isValid`

::doc-ref-section
```ts
isValid: boolean;
```

Returns whether none of the registered fields have an issue.
::

### ðŸ“˜ `this.isValidating`

::doc-ref-section
```ts
isValidating: boolean;
```

Returns whether controller is currently validating or not.
::

### ðŸ“˜ `this.isSubmitting`

::doc-ref-section
```ts
isSubmitting: boolean;
```

Returns whether controller is currently submitting or not.
::

### ðŸ“˜ `this.triedSubmitting`

::doc-ref-section
```ts
triedSubmitting: boolean;
```

Returns whether controller has tried to submit before.

This value is set to `true` at the very first submission trial.
::

---

## Methods

### ðŸ“™ `Constructor`

::doc-ref-section
```ts
export type Configs<TOutput extends object> = {
  initialData?: DeepPartial<TOutput>;
  validationSchema?: StandardSchemaV1<unknown, TOutput>;
  equalityComparators?: Map<any, (a: any, b: any) => boolean>;
};

constructor(config: FormController.Configs<TOutput>)
```

Constructs a new form controller that holds `data`, `initialData` and registered fields.
The form controller is the brain of the whole ecosystem.

#### Returns
```ts
FormController<TOutput>;
```
:::doc-tree
::::doc-tree-item{title="TOutput"}
represents the final validated shape of your form data. It defines the full object structure that the form is expected to produce after successful validation and submission.
::::
:::

#### Constructor Args

:::field-group
::::field{name="config.validationSchema?:" type="StandardSchemaV1"}
If present, the controller will use this schema to perform validations.
::::
::::field{name="config.initialData?:" type="DeepPartial<TOutput>"}
A deeply partial version of `TOutput`. If present, form will use these values as initial.
::::
::::field{name="config.equalityComparators?:" type="Map<any, (a: any, b: any) => boolean>"}
A lookup for custom equality comparators. It is used to determine if a data value is dirty, by comparing to the corresponding initialData value.
::::
:::

#### Examples

```ts
const formController = new FormController<User>({});
// ^ TOutput can be explicitly declared
```

```ts
const formController = new FormController({
  validationSchema: UserSchema, // <-- TOutput can also be infered from the schema
});
```

```ts
const formController = new FormController({
  validationSchema: UserSchema,
  initialData: { username: "" },
});
```

```ts
class Address { ... }

const formController = new FormController({
  // You can impl a custom comparison strategy for classes
  equalityComparators: new Map([
    [Address, (a: Address, b: Address) => a.equals(b)]
  ])
});
```
::

### ðŸ“™ `registerField()`

::doc-ref-section
```ts
declare function registerField<TPath extends FieldPath.Segments>(
  path: TPath,
  config?: {
    defaultValue?: Suppliable<FieldPath.Resolve<TOutput, TPath>>;
    overrideInitialValue?: boolean;
  },
);
```

Creates a new `FormField` sitting at given `TPath`, registers it to this controller and returns.

#### Returns

```ts
FormField<TOutput, FieldPath.Resolve<TOutput, TPath>>;
```
:::doc-tree
::::doc-tree-item{title="TOutput"}
represents the final validated shape of your form data. It defines the full object structure that the form is expected to produce after successful validation and submission.
::::
::::doc-tree-item{title="TPath"}
segmented path of the field respective to `TOutput`
::::
::::doc-tree-item{title="FieldPath.Resolve<TOutput, TPath>"}
value type of `TOutput` at given `TPath`
::::
:::

Field created and registered to the controller:

#### Arguments

:::field-group
::::field{name="path!" type="TPath extends FieldPath.Segments"}
Represents where this field is supposed to sit at `TOutput`.
Used while modifying, reading and validating the value of this field.
::::
::::field{name="config.defaultValue?:" type="Suppliable<FieldPath.Resolve<TOutput, TPath>>"}
If present, it will be used to set value of `this.data` at `TPath` when current value is `null | undefined`.
::::
::::field{name="config.overrideInitialValue?:" type="boolean"}
If `true`, value of `this.initialData` at `TPath` will also change with `defaultValue` when current value is `null | undefined`.
::::
:::

#### Examples

```ts
const path = formController.path.of("username");
const field = formController.registerField(path);
// formController will now have "username" field registered
```

```ts
const path = formController.path.of("email");
const field = formController.registerField(path, {
  defaultValue: "john@doe.com",
});
console.log(field.value); // <-- "john@doe.com"
console.log(field.isDirty); // <-- true
```

```ts
const path = formController.path.of("email");
const field = formController.registerField(path, {
  defaultValue: "john@doe.com",
  overrideInitialValue: true,
});
console.log(field.value); // <-- "john@doe.com"
console.log(field.isDirty); // <-- false
```
::

### ðŸ“™ `unregisterField()`

::doc-ref-section
Unregisters a `FormField` from the controller.
If no field is registered at given path, this method will do nothing effectively.

#### Signature

```ts
declare function unregisterField(path: FieldPath.Segments): boolean;
```

#### Returns

```ts
boolean;
```

Whether a field was unregistered, or not:

#### Arguments

:::field-group
::::field{name="path!" type="FieldPath.Segments"}
Path of the field to unregister.
::::
:::

#### Examples

```ts
const path = formController.path.of("username");
formController.unregisterField(path);
```

```ts
const path = formController.path.of("username");
const field = formController.registerField(path);
formController.unregisterField(field.path); // <-- true
```
::

### ðŸ“™ `getField()`

#### Examples

---

## Guides

### ðŸ“š How to blabla?

### ðŸ“š How to blabla?
