---
title: Tutorial
description:
navigation:
  icon: material-symbols-light:book-4-rounded
<!-- seo:
  title: FormController API Documentation - Type-Safe Reactive Form State & Validation Engine
  description: Comprehensive documentation for FormController ‚Äî a fully type-safe, schema-driven form state manager with field registration, reactive events, immutable data handling, and granular validation. Learn how to manage complex nested forms with predictable submission, validation, and lifecycle control. -->
---

This tutorial will guide you through building a fully controlled React signup form using the `@goodie-forms/react` bindings. By the end, you'll understand:

- How to set up a form with `useForm`.
- How to create fields with `useFormField` and `FieldRenderer`.
- How validation works with `zod` schemas (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)).
- How to handle nested objects and dynamic arrays in forms.

We'll build a User Signup form that covers names, address, friends, scores, and an inventory system.

## 1. Defining the Data Shape

::doc-ref-section
We start by defining the form data structure.
`UserForm` contains basic user info, nested objects, and optional custom classes:

```ts
class Inventory {
  contents: string[] = [];
  push(item: string) {
    this.contents.push(item);
  }
}

interface UserForm {
  name: string;
  surname: string;
  address: { city: string; street: string };
  badges: string[];
  friends: { name: string; friendshipPoints: number }[];
  inventory?: Inventory;
}
```

:::tip
Notice how `Inventory` is a custom class ‚Äî `@goodie-forms` can handle classes with custom validation.
:::
::

## 2. Adding Validation with Zod

::doc-ref-section
We can enforce strong validation using `zod` (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)):

```ts
const UserSchema = z.object({
  name: z.string().nonempty(),
  surname: z.string().nonempty(),
  address: z.object({ city: z.string(), street: z.string() }),
  friends: z.array(
    z.object({
      name: z.string(),
      friendshipPoints: z.number(),
    }),
  ),
  badges: z.array(z.string()),
  inventory: z
    .custom<Inventory>((d) => d instanceof Inventory, "Invalid inventory")
    .superRefine((d, ctx) => {
      if (d.contents.length % 2 !== 0) {
        ctx.addIssue({
          code: "custom",
          message: "Requires an even amount of items",
        });
      }
      d.contents.forEach((item, i) => {
        if (item.length < 2) {
          ctx.addIssue({
            code: "custom",
            message: "Item must be at least 2 characters long",
            path: ["contents", i],
          });
        }
      });
    })
    .optional(),
});
```

### ‚≠ê Bonus: Infer data type from Schema

Generally if you have a validation schema available,
it is more convinient to infer data type from the schema rather than manually declaring.
Most of the validation libraries provide a helper type to infer data type.

Here's how you do that with `zod`:

```ts
// Infer type from the Schema instead of manually declaring
type UserForm = z.infer<typeof UserSchema>;
```
::

## 3. Setting Up the Form Controller

::doc-ref-section
We use `useForm` to create a form controller. It manages state, validation, and submission:

```ts
const form = useForm(
  {
    validationSchema: UserSchema,
  },
  {
    validateMode: "onBlur",
    revalidateMode: "onChange",
  },
);
```

Options:

- `validateMode`: when fields initially validate (`onChange`, `onBlur`, `onSubmit`).
- `revalidateMode`: when fields validate, after the first submission attempt.

:::tip
`useForm()` is a **reactive hook** that re-renders the component when the form state (such as `form.controller.isSubmitting`) changes.
You can take advantage of this behavior to render indicators that reflect the submission status.
:::
:::tip
By default, `useForm()` does not react to individual field value changes (this can be configured using the `watchValues` option).
This ensures your component **does not re-render** unnecessarily.
:::
::

## 4. Rendering Fields

::doc-ref-section
Use `FieldRenderer` to **register** and **render** fields declaratively.

```tsx
<FieldRenderer
  form={form}
  path={form.path.of("name")}
  defaultValue={""}
  render={({ fieldProps, field, form }) => (
    <div>
      <label htmlFor="name">Name</label>

      <input
        {...fieldProps}
        id="name"
        type="text"
        disabled={form.controller.isSubmitting}
      />

      {field.issues && <span>{field.issues.at(0)?.message}</span>}
    </div>
  )}
/>;
```

### ‚≠ê Reducing Boilerplate
Rewriting a similar `render` function for every `FieldRenderer` can be exhaustive and redundant.
There are ways to standardize and reduce the boilerplating it requires.

:::accordion
::::accordion-item{label="Reduce by Using a Design System Component" icon="gravity-ui:magic-wand"}
Some external UI libraries provide a component that encapsulates a single field with a label, possible error text and etc.
Such as `Base UI`'s `<Field/>` compound component (See [their docs](https://base-ui.com/react/components/field#))

These kinds of libraries can be easily used under `FieldRenderer`'s `render` prop.

```tsx
<FieldRenderer
  form={form}
  path={form.path.of("name")}
  defaultValue={""}
  render={({ fieldProps, field, form }) => (
    <Field.Root>
      <Field.Label>Name</Field.Label>
      <input
        {...fieldProps}
        id="name"
        type="text"
        disabled={form.controller.isSubmitting}
      />
      <Field.Error match={field.issues.length !== 0}>
        {field.issues.at(0)?.message}
      </Field.Error>
    </Field.Root>
  )}
/>;
```
::::

::::accordion-item{label="Reduce by Wrapping FieldRenderer" icon="gravity-ui:magic-wand"}
Rewriting a whole set of components to render labels, error indicators etc. can be exhausting and redundantly repetitive.
To solve that and standardize how a field looks throughout your application, you can craft a new component by wrapping `FieldRenderer`.

```tsx
import type { FieldPath } from "@goodie-forms/core";
import {
  FieldRenderer,
  useFormField,
  type FieldRendererProps,
} from "@goodie-forms/react";
import { useId } from "react";

type Props<
  TOutput extends object,
  TPath extends FieldPath.Segments,
> = FieldRendererProps<TOutput, TPath> & {
  label: string;
};

export function MyField<
  TOutput extends object,
  const TPath extends FieldPath.Segments,
>(props: Props<TOutput, TPath>) {
  const id = useId();

  const field = useFormField(props.form, props.path);
  const fieldError = field?.issues.at(0);

  return (
    <div className="flex flex-col gap-2 items-start">
      <label
        className={
          field == null
            ? ""
            : !field.isValid
              ? "text-red-400"
              : field.isDirty
                ? "text-orange-300"
                : field.isTouched
                  ? "text-blue-200"
                  : ""
        }
      >
        {props.label}
      </label>

      <FieldRenderer
        form={props.form}
        path={props.path}
        defaultValue={props.defaultValue!}
        overrideInitialValue={props.overrideInitialValue}
        unbindOnUnmount={props.unbindOnUnmount}
        render={(renderParams) => {
          return (
            <div id={id} className="flex w-full *:w-full">
              {props.render(renderParams)}
            </div>
          );
        }}
      />

      {fieldError && (
        <span className="text-red-400 text-xs text-left">
          {fieldError.message}
        </span>
      )}
    </div>
  );
}
```

It can then be used easily without repeating much:

```tsx
<MyField
  form={form}
  path={form.path.of("name")}
  label="User Name"
  defaultValue="foo"
  render={({ fieldProps, form }) => (
    <input
      {...fieldProps}
      disabled={form.controller.isSubmitting}
      type="text"
      placeholder="John"
    />
  )}
/>;
```
::::
:::
::

## 5. Creating Submit Handler

::doc-ref-section
Goodie Forms provide an easy to use and

```ts
const handleSubmit = form.controller.createSubmitHandler<FormEvent>(
  async (data) => {
    const result = await api.registerUser(data);

    if (result.status === 200) {
      form.controller.reset(data); // Persist submitted data, if succeeded
    }
  },
  async (issues) => {
    console.warn("Form errors:", issues);
  },
);
```
- First callback: successful submission, provides `data` and original `event`.
- Second callback: validation errors, provides the validation `issues`.

Once creating the submit handler, you can attach it to your `<form>` element.

```tsx
<form onSubmit={handleSubmit}>
  {/* fields */}
  <button type="submit" disabled={form.controller.isSubmitting}>
    Submit
  </button>
</form>;
```

:::note
This will:
- Make it so submitting the form **triggers validation automatically** before calling your **success callback**.
- Prevent the **default HTML form submission**, so the page **won't reload**.
- Call the first callback if **the form is valid**, passing in the current form `data` and the original `event`.
- Call the second callback if **validation fails**, passing in a list of validation `issues` for you to handle or display.
- Automatically set the form state to **submitting** during the `async` operation, which you can use to **disable inputs** or **show a loading state**.
- Allow you to **reset** or **persist** the form `data` after a successful submission using `form.controller.reset(data)`.
- Integrate _seamlessly_ with **nested fields**, **dynamic arrays**, and **custom field types**, so all changes are **reflected** in the submitted `data`.
- Ensure that any **field-level** or **schema-level** _validations_ are _respected_ before submission.
- This combination of behaviors makes handling complex forms **safe**, **predictable**, and **reactive**, automatically without boilerplate `onChange` or `onBlur` wiring.
:::
::

## 6. Adding Utility Buttons

::doc-ref-section
The form controller provides convinient helpers:

```tsx
<button onClick={() => form.controller.reset()}>Reset</button>
<button onClick={() => form.controller.validateForm()}>Validate</button>
```

- Reset restores **initial values** or a **new initial values**.
- Validate triggers the schema validation manually without submitting.
::

## 7. Watching Fields, Values and Events

::doc-ref-section
While `FieldRenderer` is perfect for **binding inputs**,
sometimes you _need direct access_ to a **field** or want to _react_ to specific **value changes**, **issue changes** or a specific **event** inside your component.

This is where `useFormField()`, `useFieldValue()` and `useForm()`'s watchers shine.

### ‚öì `useFormField()` hook

:::doc-ref-section
`useFormField()` gives you full programmatic control over a specific field.

```ts
const inventoryField = useFormField(form, form.path.of("inventory"), {
  defaultValue: () => new Inventory(),
  overrideInitialValue: true,
});
```

It returns a field instance ([`FormField`](/core/formfield)) which exposes ways to directly interact with the field.

This is useful when:

- You need to **update** a field outside of an input.
- You want to **trigger changes** from _buttons_ or _side effects_.
- You need **fine-grained control** over _nested_ or _optional fields_.
:::

### ‚öì `useFieldValue()` hook

:::doc-ref-section
If you only need the **value** ‚Äî not **full control** ‚Äî you can use `useFieldValue()`.

```ts
const name = useFieldValue(form, form.path.of("name"));
```

This hook:

- Subscribes only to the given **field path**.
- Re-renders the component when **that specific `value` changes**.
- _Avoids_ re-rendering on **unrelated field updates**.
:::

### ‚öì `useFieldIssues()` hook

:::doc-ref-sections
If you only need the **issues** ‚Äî not **full control** ‚Äî you can use `useFieldIssues()`.

```ts
const nameIssues = useFieldIssues(form, form.path.of("name"));
```

This hook:
- Subscribes only to validation `issues` of the given **field path**.
- Re-renders the component when **that field's `issues` change**.
- _Avoids_ re-rendering on **unrelated value or form updates**.
:::

### ‚öì `useForm()` watchers

:::doc-ref-section
By default, `useForm()` does not re-render your component when **arbitrary form values** or **validation issues change**.

This is _intentional_ ‚Äî it keeps your components performant and avoids unnecessary re-renders.

However, in some scenarios, you may **want** your component to _react_ to:

- _Any change_ in form `data` via `form.watchValues()`
- _Any change_ in validation `issues` via `form.watchIssues()`
- _Any event_ emitted by the `form.controller.events` via `form.watchEvent()`

For those cases, `useForm()` exposes reactive watcher hooks:
```ts
const form = useForm({
  validationSchema: UserSchema,
});

const values = form.watchValues();
const issues = form.watchIssues();

form.watchEvent("fieldTouchUpdated");
// ^ Triggers re-renders on a field's isTouched change

form.watchEvent("fieldDirtyUpdated", (path) => console.log(path));
// ^ A listener can also be attached
```

These functions behave like hooks:

- They **subscribe** to _internal controller events_.
- They trigger **re-renders** when the _relevant state changes_.
- They **only affect** the component _that calls them_.
- If you **don't call** them, _no subscription is created_.
:::

### üëÅ‚Äçüó® `watchValues()` watcher

:::doc-ref-section
When enabled:

- The component **re-renders** whenever the form `data` changes.
- You **always** receive the _latest values_.
- Useful for **previews**, **dashboards**, and **debugging panels**.

Example:
```tsx
const form = useForm({
  validationSchema: UserSchema,
});

const values = form.watchValues();

return (
  <>
    <RegistrationForm form={form} />
    <pre>{JSON.stringify(values, null, 2)}</pre>
  </>
);
```
If `watchValues()` is not called, the preview will **not** update.

This makes the **subscription** explicit and _opt-in_.
:::

### üëÅ‚Äçüó® `watchIssues()` watcher

:::doc-ref-section
When enabled:

- The component **re-renders** whenever validation `issues` change.
- You **always** receive the latest `issues`.
- Useful for **global error summaries**.
- Ideal for showing a **"Form has errors" banner**.

Example:
```tsx
const form = useForm({
  validationSchema: UserSchema,
});

const issues = form.watchIssues();
const hasErrors = issues.length > 0;

return hasErrors ? (
  <div className="error-banner">Please fix the highlighted errors.</div>
) : null;
```
If `watchIssues()` is **not** called, the component **will not react** to validation changes.
:::

### üëÅ‚Äçüó® `watchEvent()` watcher

:::doc-ref-section
When invoked:

- The component **re-renders** whenever the specified **event** fires.
- You can _optionally_ provide a **listener** to execute custom logic when the **event occurs**.
- Designed as a **low-level reactive primitive**.
- Ideal for **advanced scenarios** and **custom reactive behaviors**.

Unlike `form.watchValues()` or `form.watchIssues()`, which are **high-level** convenience helpers,
`form.watchEvent()` gives you **direct access** to the _form controller's event system_.

```tsx
const form = useForm({
  validationSchema: UserSchema,
});

form.watchEvent("fieldTouchUpdated");
// ^ Triggers re-renders on a field's isTouched change
return <RegistrationForm form={form} />;
```
```tsx
// You can pass in a listener callback too
form.watchEvent("validationStatusChange", (isValidating) => {
  if (isValidating) {
    console.log("Hold up, for is now validating...");
  } else {
    console.log("Validation is done");
  }
});
```
:::

### üìö Example 1: Auto-Capitalize Name

:::doc-ref-section
```ts
const nameField = useFormField(form, form.path.of("name"));

useEffect(() => {
  if (!nameField.value) return;

  const normalized =
    nameField.value.charAt(0).toUpperCase() +
    nameField.value.slice(1).toLowerCase();

  if (normalized !== nameField.value) {
    nameField.setValue(normalized);
  }
}, [nameField.value]);
```
:::

### üìö Example 2: Enable Inventory Only After Address Is Filled

:::doc-ref-section
Imagine your business rule is:

> Users can only manage inventory after providing a valid city.

Instead of checking this inside each button, you can reactively control the UI:

```ts
const city = useFieldValue(form, form.path.of("address.city"));
const inventoryField = useFormField(form, form.path.of("inventory"));
```
```tsx
<fieldset disabled={city === ""}>
  <InventorySection form={form} />
</fieldset>;
```
:::

### üìö Example 3: Live Form Completion Indicator

:::doc-ref-section
A common real-world feature is showing progress:

```ts
const name = useFieldValue(form, form.path.of("name"));
const surname = useFieldValue(form, form.path.of("surname"));
const city = useFieldValue(form, form.path.of("address.city"));
```
```ts
const completedFields = [name, surname, city].filter(Boolean).length;
const progress = (completedFields / 3) * 100;
```
```tsx
<div className="progress-bar">
  <div style={{ width: `${progress}%` }} />
</div>;
```
:::

### üìö Example 4: Hint If Inventory Is Empty

:::doc-ref-section
Instead of relying purely on _schema validation_, you might want a **soft UX warning**:

```ts
const inventory = useFieldValue(form, form.path.of("inventory"));
const hasItems = inventory?.contents?.length > 0;
```
```tsx
<>
  {!hasItems && (
    <p className="text-yellow-500 text-sm">You haven't added any items yet.</p>
  )}
</>;
```
:::

### üìö Example 5: Cross-Field Derived Preview

:::doc-ref-section
```ts
const name = useFieldValue(form, form.path.of("name"));
const surname = useFieldValue(form, form.path.of("surname"));
```

```tsx
<div className="preview-card">
  <strong>Public Profile Preview</strong>
  <p>
    {name || "First"} {surname || "Last"}
  </p>
</div>;
```
:::

### üìö Example 6: Disable Submit Until Form Is Valid

:::doc-ref-section
```ts

```
:::

### üìö Example 7: Registration Summary Step

:::doc-ref-section
Imagine a 2-step registration process:

- **Step 1**: _Fill the form_
- **Step 2**: _Review before final submission_

```ts
const form = useForm({
  validationSchema: UserSchema,
});

const values = form.watchValues();
const issues = form.watchIssues();
```
```tsx
<div className="summary">
  <h3>Review Your Information</h3>

  <p>
    <strong>Name:</strong> {values.name}
  </p>
  <p>
    <strong>Surname:</strong> {values.surname}
  </p>
  <p>
    <strong>City:</strong> {values.address?.city}
  </p>

  {issues.length > 0 && (
    <div className="warning">Some fields need attention before submission.</div>
  )}
</div>;
```
:::
::

## Takeaways

::doc-ref-section
- `useForm()` creates a **centralized**, **reactive** form state and wires up **validation** and **submission** behavior.
  - `form.watchValues()` lets a component subscribe to all **form data changes** ‚Äî re-rendering only where it is called.
  - `form.watchIssues()` lets a component subscribe to all **validation issue changes** ‚Äî ideal for global error summaries or banners.
  - `form.watchEvent()` lets a component subscribe to a **specific internal form lifecycle event** ‚Äî enabling _fine-grained reactivity_ and _custom behavior_ built on top of the controller's _event system_.
- `useFormField()` gives you full programmatic control over a **specific field** ‚Äî including _setting_, _modifying_, _focusing_, and _inspecting its state_.
- `useFieldValue()` lets you subscribe to a **single field's value** with fine-grained _reactivity_ and _minimal re-renders_.
- `FieldRenderer` (or your _custom wrapper_) integrates **any UI component** with automatic **field binding**.
- `FormController` (`form.controller`) handles **submission**, **validation lifecycle**, **resetting**, and **all form-level operations**.
- Supports **deeply nested objects**, **dynamic arrays**, and even **custom class instances** out-of-the-box.

Together, these **primitives** let you build **complex**, **high-performance** forms with *explicit reactivity* and *minimal boilerplate* ‚Äî while keeping behavior **predictable** and **scalable**.
::
