---
title: Tutorial
description:
navigation:
  icon: material-symbols-light:book-4-rounded
<!-- seo:
  title: FormController API Documentation - Type-Safe Reactive Form State & Validation Engine
  description: Comprehensive documentation for FormController — a fully type-safe, schema-driven form state manager with field registration, reactive events, immutable data handling, and granular validation. Learn how to manage complex nested forms with predictable submission, validation, and lifecycle control. -->
---

This tutorial will guide you through building a fully controlled React signup form using the `@goodie-forms/react` bindings. By the end, you'll understand:

- How to set up a form with `useForm`.
- How to create fields with `useFormField` and `FieldRenderer`.
- How validation works with `zod` schemas (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)).
- How to handle nested objects and dynamic arrays in forms.

We'll build a User Signup form that covers names, address, friends, scores, and an inventory system.

## 1. Defining the Data Shape

::doc-ref-section
We start by defining the form data structure.
`UserForm` contains basic user info, nested objects, and optional custom classes:

```ts
class Inventory {
  contents: string[] = [];
  push(item: string) {
    this.contents.push(item);
  }
}

interface UserForm {
  name: string;
  surname: string;
  address: { city: string; street: string };
  badges: string[];
  friends: { name: string; friendshipPoints: number }[];
  inventory?: Inventory;
}
```

:::tip
Notice how `Inventory` is a custom class — `@goodie-forms` can handle classes with custom validation.
:::
::

## 2. Adding Validation with Zod

::doc-ref-section
We can enforce strong validation using `zod` (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)):

```ts
const UserSchema = z.object({
  name: z.string().nonempty(),
  surname: z.string().nonempty(),
  address: z.object({ city: z.string(), street: z.string() }),
  friends: z.array(
    z.object({
      name: z.string(),
      friendshipPoints: z.number(),
    }),
  ),
  badges: z.array(z.string()),
  inventory: z
    .custom<Inventory>((d) => d instanceof Inventory, "Invalid inventory")
    .superRefine((d, ctx) => {
      if (d.contents.length % 2 !== 0) {
        ctx.addIssue({
          code: "custom",
          message: "Requires an even amount of items",
        });
      }
      d.contents.forEach((item, i) => {
        if (item.length < 2) {
          ctx.addIssue({
            code: "custom",
            message: "Item must be at least 2 characters long",
            path: ["contents", i],
          });
        }
      });
    })
    .optional(),
});
```

### Infer data type from Schema

```ts
// Or infer type from the Schema instead of manually declaring
type UserForm = z.infer<typeof UserSchema>;
```
::

## 3. Setting Up the Form Controller

::doc-ref-section
We use `useForm` to create a form controller. This manages state, validation, and submission:

```ts
const form = useForm(
  {
    validationSchema: UserSchema,
  },
  {
    validateMode: "onBlur",
    revalidateMode: "onChange",
  },
);
```

Options:

- `validateMode`: when fields initially validate (`onChange`, `onBlur`, `onSubmit`).
- `revalidateMode`: when fields validate, after the first submission trial.
::

## 4. Rendering Fields

::doc-ref-section
Use `FieldRenderer` to register and render fields declaratively.

```tsx
<FieldRenderer
  form={form}
  path={form.path.of("name")}
  defaultValue={""}
  render={({ fieldProps, field, form }) => (
    <div>
      <label htmlFor="name">Name</label>

      <input
        {...fieldProps}
        id="name"
        type="text"
        disabled={form.controller.isSubmitting}
      />

      {field.issues && <span>{field.issues.at(0)?.message}</span>}
    </div>
  )}
/>;
```
::
