---
title: Tutorial
description:
navigation:
  icon: material-symbols-light:book-4-rounded
<!-- seo:
  title: FormController API Documentation - Type-Safe Reactive Form State & Validation Engine
  description: Comprehensive documentation for FormController — a fully type-safe, schema-driven form state manager with field registration, reactive events, immutable data handling, and granular validation. Learn how to manage complex nested forms with predictable submission, validation, and lifecycle control. -->
---

This tutorial will guide you through building a fully controlled React signup form using the `@goodie-forms/react` bindings. By the end, you'll understand:

- How to set up a form with `useForm`.
- How to create fields with `useFormField` and `FieldRenderer`.
- How validation works with `zod` schemas (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)).
- How to handle nested objects and dynamic arrays in forms.

We'll build a User Signup form that covers names, address, friends, scores, and an inventory system.

## 1. Defining the Data Shape

::doc-ref-section
We start by defining the form data structure.
`UserForm` contains basic user info, nested objects, and optional custom classes:

```ts
class Inventory {
  contents: string[] = [];
  push(item: string) {
    this.contents.push(item);
  }
}

interface UserForm {
  name: string;
  surname: string;
  address: { city: string; street: string };
  badges: string[];
  friends: { name: string; friendshipPoints: number }[];
  inventory?: Inventory;
}
```

:::tip
Notice how `Inventory` is a custom class — `@goodie-forms` can handle classes with custom validation.
:::
::

## 2. Adding Validation with Zod

::doc-ref-section
We can enforce strong validation using `zod` (or [any other StandardSchemaV1 schemas](https://standardschema.dev/schema#what-schema-libraries-implement-the-spec)):

```ts
const UserSchema = z.object({
  name: z.string().nonempty(),
  surname: z.string().nonempty(),
  address: z.object({ city: z.string(), street: z.string() }),
  friends: z.array(
    z.object({
      name: z.string(),
      friendshipPoints: z.number(),
    }),
  ),
  badges: z.array(z.string()),
  inventory: z
    .custom<Inventory>((d) => d instanceof Inventory, "Invalid inventory")
    .superRefine((d, ctx) => {
      if (d.contents.length % 2 !== 0) {
        ctx.addIssue({
          code: "custom",
          message: "Requires an even amount of items",
        });
      }
      d.contents.forEach((item, i) => {
        if (item.length < 2) {
          ctx.addIssue({
            code: "custom",
            message: "Item must be at least 2 characters long",
            path: ["contents", i],
          });
        }
      });
    })
    .optional(),
});
```

### Infer data type from Schema

```ts
// Or infer type from the Schema instead of manually declaring
type UserForm = z.infer<typeof UserSchema>;
```
::

## 3. Setting Up the Form Controller

::doc-ref-section
We use `useForm` to create a form controller. This manages state, validation, and submission:

```ts
const form = useForm(
  {
    validationSchema: UserSchema,
  },
  {
    validateMode: "onBlur",
    revalidateMode: "onChange",
  },
);
```

Options:

- `validateMode`: when fields initially validate (`onChange`, `onBlur`, `onSubmit`).
- `revalidateMode`: when fields validate, after the first submission trial.
::

## 4. Rendering Fields

::doc-ref-section
Use `FieldRenderer` to register and render fields declaratively.

```tsx
<FieldRenderer
  form={form}
  path={form.path.of("name")}
  defaultValue={""}
  render={({ fieldProps, field, form }) => (
    <div>
      <label htmlFor="name">Name</label>

      <input
        {...fieldProps}
        id="name"
        type="text"
        disabled={form.controller.isSubmitting}
      />

      {field.issues && <span>{field.issues.at(0)?.message}</span>}
    </div>
  )}
/>;
```

:::accordion
::::accordion-item{label="Reduce Boilerplate: Field Design System Component" icon="gravity-ui:magic-wand"}
Some external UI libraries provide a component that encapsulates a single field with a label, possible error text and etc.
Such as `Base UI`'s `<Field/>` compound component (See [their docs](https://base-ui.com/react/components/field#))

These kinds of libraries can be easily used under `FieldRenderer`'s `render` prop.

```tsx
<FieldRenderer
  form={form}
  path={form.path.of("name")}
  defaultValue={""}
  render={({ fieldProps, field, form }) => (
    <Field.Root>
      <Field.Label>Name</Field.Label>
      <input
        {...fieldProps}
        id="name"
        type="text"
        disabled={form.controller.isSubmitting}
      />
      <Field.Error match={field.issues.length !== 0}>
        {field.issues.at(0)?.message}
      </Field.Error>
    </Field.Root>
  )}
/>;
```
::::

::::accordion-item{label="Reduce Boilerplate: Wrap FieldRenderer" icon="gravity-ui:magic-wand"}
Rewriting a whole set of components to render labels, error indicators etc. can be exhausting and redundantly repetitive.
To solve that and standardize how a field looks thruought your application, you can craft a new component by wrapping `FieldRenderer`.

```tsx
import type { FieldPath } from "@goodie-forms/core";
import {
  FieldRenderer,
  useFormField,
  type FieldRendererProps,
} from "@goodie-forms/react";
import { useId } from "react";

type Props<
  TOutput extends object,
  TPath extends FieldPath.Segments,
> = FieldRendererProps<TOutput, TPath> & {
  label: string;
};

export function MyField<
  TOutput extends object,
  const TPath extends FieldPath.Segments,
>(props: Props<TOutput, TPath>) {
  const id = useId();

  const field = useFormField(props.form, props.path);
  const fieldError = field?.issues.at(0);

  return (
    <div className="flex flex-col gap-2 items-start">
      <label
        className={
          field == null
            ? ""
            : !field.isValid
              ? "text-red-400"
              : field.isDirty
                ? "text-orange-300"
                : field.isTouched
                  ? "text-blue-200"
                  : ""
        }
      >
        {props.label}
      </label>

      <FieldRenderer
        form={props.form}
        path={props.path}
        defaultValue={props.defaultValue!}
        overrideInitialValue={props.overrideInitialValue}
        unbindOnUnmount={props.unbindOnUnmount}
        render={(renderParams) => {
          return (
            <div id={id} className="flex w-full *:w-full">
              {props.render(renderParams)}
            </div>
          );
        }}
      />

      {fieldError && (
        <span className="text-red-400 text-xs text-left">
          {fieldError.message}
        </span>
      )}
    </div>
  );
}
```

It can then be used easily without repeating much:

```tsx
<MyField
  form={form}
  path={form.path.of("name")}
  label="User Name"
  defaultValue="foo"
  render={({ fieldProps, form }) => (
    <input
      {...fieldProps}
      disabled={form.controller.isSubmitting}
      type="text"
      placeholder="John"
    />
  )}
/>;
```
::::
:::
::
